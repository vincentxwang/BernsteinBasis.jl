var documenterSearchIndex = {"docs":
[{"location":"api/","page":"Full API","title":"Full API","text":"CurrentModule = BernsteinBasis","category":"page"},{"location":"api/#BernsteinBasis","page":"Full API","title":"BernsteinBasis","text":"","category":"section"},{"location":"api/","page":"Full API","title":"Full API","text":"Documentation for BernsteinBasis.","category":"page"},{"location":"api/","page":"Full API","title":"Full API","text":"","category":"page"},{"location":"api/","page":"Full API","title":"Full API","text":"Modules = [BernsteinBasis]","category":"page"},{"location":"api/#BernsteinBasis.BernsteinDerivativeMatrix_3D_r","page":"Full API","title":"BernsteinBasis.BernsteinDerivativeMatrix_3D_r","text":"BernsteinDerivativeMatrix_3D_r <: AbstractMatrix{Float64}\n\nDerivative matrix with respect to the first Cartesian coordinate r in the 3D Bernstein basis.\n\nFields\n\nN::Int: Order of Bernstein polynomials. Supports up to N = 20.\n\n\n\n\n\n","category":"type"},{"location":"api/#BernsteinBasis.BernsteinDerivativeMatrix_3D_s","page":"Full API","title":"BernsteinBasis.BernsteinDerivativeMatrix_3D_s","text":"BernsteinDerivativeMatrix_3D_s <: AbstractMatrix{Float64}\n\nDerivative matrix with respect to the second Cartesian coordinate s in the 3D Bernstein basis.\n\nFields\n\nN::Int: Order of Bernstein polynomials. Supports up to N = 20.\n\n\n\n\n\n","category":"type"},{"location":"api/#BernsteinBasis.BernsteinDerivativeMatrix_3D_t","page":"Full API","title":"BernsteinBasis.BernsteinDerivativeMatrix_3D_t","text":"BernsteinDerivativeMatrix_3D_t <: AbstractMatrix{Float64}\n\nDerivative matrix with respect to the third Cartesian coordinate t in the 3D Bernstein basis.\n\nFields\n\nN::Int: Order of Bernstein polynomials. Supports up to N = 20.\n\n\n\n\n\n","category":"type"},{"location":"api/#BernsteinBasis.BernsteinLift","page":"Full API","title":"BernsteinBasis.BernsteinLift","text":"BernsteinLift\n\nLift matrix for a single face on a standard tetrahedron. Supports mul! operations, but should optimally be used for matrix-vector multiplications rather than matrix-matrix multiplications.\n\nChan, Jesse and Tim Warburton (2017) GPU-accelerated Bernstein-Bezier discontinuous Galerkin methods for wave problems DOI: 10.48550/arXiv.1512.06025\n\n\n\n\n\n","category":"type"},{"location":"api/#BernsteinBasis.ElevationMatrix","page":"Full API","title":"BernsteinBasis.ElevationMatrix","text":"ElevationMatrix{N} <: AbstractMatrix{Float64}\n\nTwo-dimensional degree elevation operator for Bernstein polynomials. Expresses polynomials of degree N - 1 as polynomials of degree N.\n\nKirby, Robert C. (2016) Fast inversion of the simplicial Bernstein mass matrix DOI: 10.1007/s00211-016-0795-0\n\n\n\n\n\n","category":"type"},{"location":"api/#BernsteinBasis.MultithreadedBernsteinLift","page":"Full API","title":"BernsteinBasis.MultithreadedBernsteinLift","text":"MultithreadedBernsteinLift\n\nA multithreaded-friendly lift matrix for a single face on a standard tetrahedron. Supports  mul! operations, but should optimally be used for matrix-vector multiplications rather than matrix-matrix multiplications.\n\nChan, Jesse and Tim Warburton (2017) GPU-accelerated Bernstein-Bezier discontinuous Galerkin methods for wave problems DOI: 10.48550/arXiv.1512.06025\n\n\n\n\n\n","category":"type"},{"location":"api/#BernsteinBasis.bernstein_2d_scalar_multiindex_lookup-Tuple{Any}","page":"Full API","title":"BernsteinBasis.bernstein_2d_scalar_multiindex_lookup","text":"bernstein_2d_scalar_multiindex_lookup(N)\n\nReturns a vector that maps scalar indices to multi-indices of the N-th degree Bernstein polynomials.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.bernstein_basis-Tuple{NodesAndModes.Line, Any, Any}","page":"Full API","title":"BernsteinBasis.bernstein_basis","text":"bernstein_basis(::Line, N, r)\nbernstein_basis(elem::Tri, N, r, s)\nbernstein_basis(elem::Tet, N, r, s, t)\n\nWrapper for bernstein_basis_from_barycentric that takes in rst-space coordinates, each in  -1 1, instead of barycentric coordinates.\n\nReturns the N_p x N_p generalized Vandermonde matrix mathcalV, where mathcalV_mn =  the n-th Bernstein basis evaluated at the m-th point, followed by its derivative matrices.\n\nUse ::Line for 1D, ::Tri for 2D, and ::Tet for 3D. \n\nWe order the Bernstein basis according to exponents in a \"reverse-dictionary\" order of the first DIM-1 coordinates. Does not work for N  20 because of factorial() limitations.\n\nArguments\n\nN::Int: Bernstein basis degree\nr,s,t::AbstractArray{T,1}: N_p-sized vectors of distinct 2D barycentric coordinates to be \n\nused as interpolatory points\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.bernstein_basis_from_barycentric-Tuple{NodesAndModes.Line, Any, Any, Any}","page":"Full API","title":"BernsteinBasis.bernstein_basis_from_barycentric","text":"bernstein_basis_from_barycentric(::Line, N, r, s)\nbernstein_basis_from_barycentric(::Tri, N, r, s, t)\nbernstein_basis_from_barycentric(::Tet, N, r, s, t, u)\n\nReturns the N_p x N_p generalized Vandermonde matrix mathcalV, where mathcalV_mn =  the n-th Bernstein basis evaluated at the m-th point, followed by its derivative matrices.\n\nUse ::Line for 1D, ::Tri for 2D, and ::Tet for 3D. \n\nWe order the Bernstein basis according to exponents in a \"reverse-dictionary\" order of the first DIM-1 coordinates. Does not work for N  20 because of factorial() limitations.\n\nArguments\n\nN::Int: Bernstein basis degree\nr,s,t::AbstractArray{T,1}: N_p-sized vectors of distinct 2D barycentric coordinates to be \n\nused as interpolatory points\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.cartesian_to_barycentric-Tuple{NodesAndModes.Line, AbstractMatrix}","page":"Full API","title":"BernsteinBasis.cartesian_to_barycentric","text":"cartesian_to_barycentric(elem::Union{Line, Tri, Tet}, coords)\ncartesian_to_barycentric(elem::Union{Line, Tri, Tet}, coords...)\n\nConverts a DIMS by N_p matrix of cartesian coordinates into a matrix of barycentric coordinates. Alternatively, also takes in DIMS number of vectors of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.elevation_multiply!-NTuple{4, Any}","page":"Full API","title":"BernsteinBasis.elevation_multiply!","text":"elevation_multiply!(out, N, x, offset)\n\nMultiplies x by the 2D Bernstein elevation matrix that maps from degree N polynomials to  N + 1.\n\ntri_offsets(N) should be passed as the precomputed offset value.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.face_lift_multiply!-NTuple{5, Any}","page":"Full API","title":"BernsteinBasis.face_lift_multiply!","text":"fast_lift_multiply!(out, N, L0, x, offset, l_j, E)\n\nMultiplies x by the \"nice\" lift matrix face (rs-plane) of the lift matrix.\n\nArguments\n\nx::AbstractVector: Input vector\nChan, Jesse and Tim Warburton (2017) GPU-accelerated Bernstein-Bezier discontinuous Galerkin methods for wave problems DOI: 10.48550/arXiv.1512.06025\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.get_bernstein_lift-Tuple{Any}","page":"Full API","title":"BernsteinBasis.get_bernstein_lift","text":"get_bernstein_lift(N)\n\nReturns an N-degree 3D Bernstein lift matrix as a Matrix type, in contrast to the  more optimized BernsteinLift(N).\n\nThis function is derived from StartUpDG's Tet() struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.get_coeff-NTuple{8, Any}","page":"Full API","title":"BernsteinBasis.get_coeff","text":"get_coeff(i1, j1, k1, l1, i2, j2, k2, l2)\n\nReturns the value of the (i1, j1, k1, l1), (i2, j2, k2, l2)-th entry of the 3D Bernstein derivative  matrix with respect to i (first barycentric coordinate).\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.ij_to_linear-Tuple{Any, Any, Any}","page":"Full API","title":"BernsteinBasis.ij_to_linear","text":"ij_to_linear(i,j,offset)\n\nReturns the scalar index of the (ijk)-th 2D Bernstein basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.ijk_to_linear-NTuple{5, Any}","page":"Full API","title":"BernsteinBasis.ijk_to_linear","text":"ijk_to_linear(i,j,offset)\n\nReturns the scalar index of the (ijkl)-th 3D Bernstein basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.l_j-Tuple{Any}","page":"Full API","title":"BernsteinBasis.l_j","text":"l_j(N)\n\nReturns a tuple containing l_1  l_N  l_20 as specified by the lift matrix multiplication algorithm in\n\nChan, Jesse and Tim Warburton (2017) GPU-accelerated Bernstein-Bezier discontinuous Galerkin methods for wave problems DOI: 10.48550/arXiv.1512.06025\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.reduction_multiply!-NTuple{4, Any}","page":"Full API","title":"BernsteinBasis.reduction_multiply!","text":"reduction_multiply!(out, N, x, offset)\n\nMultiplies x by the 2D Bernstein reduction matrix that maps from degree N polynomials to  N - 1.\n\ntri_offsets(N) should be passed as the precomputed offset value.\n\n\n\n\n\n","category":"method"},{"location":"api/#BernsteinBasis.threaded_mul!-Union{Tuple{T}, Tuple{AbstractVector{T}, MultithreadedBernsteinLift, AbstractVector{T}, Any}} where T","page":"Full API","title":"BernsteinBasis.threaded_mul!","text":"threaded_mul!(out::AbstractVector, L::BernsteinLift, x::AbstractVector)\n\nMultiplies x by the Bernstein lift matrix L, as defined in documentation.\n\nArguments\n\nout::AbstractVector: Length rac(N+1)(N+2)(N+3)6 vector\nL::BernsteinLift: Order N Bernstein lift matrix\nx::AbstractVector: Length 2 cdot \frac(N+1)(N+2)2 vector\nthread: Thread id\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Tuple{AbstractVector, BernsteinLift, AbstractVector}","page":"Full API","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(out::AbstractVector, L::BernsteinLift, x::AbstractVector)\n\nMultiplies x by the Bernstein lift matrix L, as defined in documentation.\n\nArguments\n\nout::AbstractVector: Length rac(N+1)(N+2)(N+3)6 vector\nL::BernsteinLift: Order N Bernstein lift matrix\nx::AbstractVector: Length 2 cdot \frac(N+1)(N+2)2 vector\n\n\n\n\n\n","category":"method"},{"location":"lift/#Lift","page":"Lift","title":"Lift","text":"","category":"section"},{"location":"lift/","page":"Lift","title":"Lift","text":"For a face f, we define the lift matrix mathbfL^f to be","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"mathbfL^f = mathbfM^-1mathbfM^f","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"where mathbfM and mathbfM^f are the Bernstein mass matrices defined by","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"beginaligned\nmathbfM_ij = int_hatD phi_i phi_j \nmathbfM_ij^f = int_f_hatD phi_i varphi_j \nendaligned","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"where varphi_j_j=1^j=fracN(N+1)2 is the subset of phi_j_j=1^j=fracN(N+1)(N+2)6 that is not constantly zero on f, or the trace of the polynomial space.","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"We define mathbfL (synonymous with BernsteinLift) to be","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"mathbfL = left beginarraycccc mathbfL^1  mathbfL^2  mathbfL^3  mathbfL^4 endarray right","category":"page"},{"location":"lift/","page":"Lift","title":"Lift","text":"This BernsteinLift implementation transforms a vector in an optimal O(N^3), improving upon the typical O(N^5) time complexity of multiplying a dense nodal lift matrix by a vector.","category":"page"},{"location":"derivative/#Derivative","page":"Derivative","title":"Derivative","text":"","category":"section"},{"location":"derivative/","page":"Derivative","title":"Derivative","text":"We define the 3D Bernstein derivative matrices bmD^rbmD^s bmD^t (synonymous with BernsteinDerivativeMatrix_3D_r, BernsteinDerivativeMatrix_3D_s, BernsteinDerivativeMatrix_3D_t respectively) to be the linear operators that satisfy","category":"page"},{"location":"derivative/","page":"Derivative","title":"Derivative","text":"sum_j=1^N_p(bmD^r bmp)_j  psi_j = fracpartial ppartial r quad quad sum_j=1^N_p(bmD^s bmp)_j  psi_j = fracpartial ppartial s quad quad sum_j=1^N_p(bmD^t bmp)_j  psi_j = fracpartial ppartial t","category":"page"},{"location":"derivative/","page":"Derivative","title":"Derivative","text":"where bmp are the coefficients representing a polynomial p = sum_j=1^N_p bmp_j psi_j.","category":"page"},{"location":"derivative/","page":"Derivative","title":"Derivative","text":"In contrast to a nodal scheme which has a dense N_p times N_p matrix that multiplies a vector in O(N_p^2) = O(N^6), we exploit sparsity in the Bernstein derivative matrix to multiply a vector in optimal O(N^3) time complexity.","category":"page"},{"location":"#BernsteinBasis","page":"Home","title":"BernsteinBasis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains optimized reference element operators and algorithms for using a Bernstein basis in discontinuous Galerkin methods.","category":"page"},{"location":"notation/#Notation-and-conventions","page":"Notations and conventions","title":"Notation and conventions","text":"","category":"section"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"Generally, we follow the same conventions as GPU-accelerated Bernstein-Bezier discontinuous Galerkin methods for wave problems (Chan and Warburton 2017).","category":"page"},{"location":"notation/#Reference-tetrahedron","page":"Notations and conventions","title":"Reference tetrahedron","text":"","category":"section"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"We define our reference tetrahedron hatD in rst-space by","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"hatD = -1 leq rst mid r + s + t leq 1","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"We define the barycentric coordinates lambda_0 lambda_1 lambda_2 lambda_3 on hatD by","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"beginaligned\nlambda_0 = frac1 + r2  lambda_1 = frac1 + s2  lambda_2 = frac1 + t2  lambda_3 = - frac1 + r + s + t2 \nendaligned","category":"page"},{"location":"notation/#Bernstein-basis","page":"Notations and conventions","title":"Bernstein basis","text":"","category":"section"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"Consider 4-tuples of non-negative integers (i j k l) satisfying i + j + k + l = N, where N is the desired degree of the Bernstein basis. Using these tuples, we define the (i j k l)-th three-dimensional Bernstein basis function psi_(ijkl) as","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"psi_(i j k l) = fracNijkl lambda_0^i lambda_1^j lambda_2^k lambda_3^l","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"Note that there exist ","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"N_p = frac(N + 1)(N + 2)(N + 3)6","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"of these tuples for an N-degree 3D Bernstein basis. ","category":"page"},{"location":"notation/","page":"Notations and conventions","title":"Notations and conventions","text":"We will also assign each basis function a scalar index n by ordering the first three coordinates in reverse dictionary order. The ordering.jl file contains tools for efficiently converting between the two.","category":"page"}]
}
