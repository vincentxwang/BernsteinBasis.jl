using StartUpDG
using OrdinaryDiffEq
using Test
using LinearAlgebra
using BernsteinBasis

N = 7
rd = RefElemData(Tet(), N)

# create interp matrix from Fmask node ordering to quadrature node ordering
(; r, s, Fmask) = rd

Fmask = reshape(Fmask, :, 4)

rf, sf = rd.r[Fmask[:,1]], rd.t[Fmask[:,1]]
rd = RefElemData(Tet(), N; quad_rule_face = (rf, sf, ones(length(rf))))
md = MeshData(uniform_mesh(rd.element_type, 2), rd;               
              is_periodic=true)


a = @. (1+rd.r)/2
b = @. (1+rd.s)/2
c = @. (1+rd.t)/2
d = @. -(1+rd.r+rd.s+rd.t)/2

vander, _ = bernstein_basis(Tet(), N, a, b,c,d)

# @test inv(vander) * rd.Dr * vander â‰ˆ  BernsteinDerivativeMatrix_1D_r(N)

# quad points = interp points but the polynomial is = 1 at the endpoints

Dr = BernsteinDerivativeMatrix_3D_r(N)
Ds = BernsteinDerivativeMatrix_3D_s(N)
Dt = BernsteinDerivativeMatrix_3D_t(N)

LIFT = BernsteinLift(N)

u0 = @. sin(pi * md.x) * sin(pi * md.y) * sin(pi * md.z)

function rhs!(du, u, params, t)
    (; LIFT, rd, interface_flux) = params

    uM = view(u, rd.Fmask, :)
    
    for e in axes(uM, 2)
        for i in axes(uM, 1)
            interface_flux[i, e] = 0.5 * (uM[md.mapP[i,e]] - uM[i,e]) * md.nxJ[i,e] - 
                                   0.5 * (uM[md.mapP[i,e]] - uM[i,e]) * md.Jf[i,e]
        end
    end
    
    # interfa
    # interface_flux = @. 0.5 * (uP + uM)/2 + 1000/2 * (uP - uM) * md.nxJ
    dudxJ = md.rxJ .* (Dr * u) + md.sxJ .* (Ds * u) + md.txJ .* (Dt * u)
    du .= -(dudxJ + LIFT * interface_flux) ./ md.J
end

for e in size(u0, 2)
    u0[:,e] = inv(vander) * u0[:,e]
end

tspan = (0.0, 1.0)

ode = ODEProblem(rhs!, u0, tspan, (; LIFT, rd, interface_flux = md.x[rd.Fmask, :]))
sol = solve(ode, RK4(), saveat=LinRange(tspan..., 25))

u = sol.u[end]

for e in size(u0, 2)
    u[:,e] = vander * u[:,e]
end

u_exact = @. sin(pi * (md.x - tspan[2])) * sin(pi * md.y) * sin(pi * md.z)

@show norm(u - u_exact, Inf)



